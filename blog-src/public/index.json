[{"content":"ğŸ§Š Ever wanted to insert one container inside another in X++?\nWhether you\u0026rsquo;re working with temporary in-memory structures or building payloads for integrations, this trick can help you dynamically group rows into containers â€” just like a 2D array!\nLetâ€™s dive in. ğŸ’»\nğŸš€ The Problem You want to loop through a dataset (like IDs and names), create a container for each row, and nest those containers into one master container.\nSounds simple â€” but you need to do it the right way to avoid mistakes like flattening your data.\nğŸ§ª Solution 1: Using += (Append Operator) This is the cleanest and most common way to insert a container into another container.\nstatic void InsertUsingPlusEquals(Args _args) { container parentCon; container childCon; int id; str name; for (int i = 1; i \u0026lt;= 5; i++) { id = i; name = strFmt(\u0026#34;Name_%1\u0026#34;, i); childCon = conNull(); // Clear before reuse! childCon += id; childCon += name; parentCon += [childCon]; // Correct: Wrap in [] to insert as 1 item } // (Optional) we print to verify for (int j = 1; j \u0026lt;= conLen(parentCon); j++) { container row = conPeek(parentCon, j); info(strFmt(\u0026#34;Row %1 - ID: %2, Name: %3\u0026#34;, j, conPeek(row, 1), conPeek(row, 2))); } } ğŸ”¥ Key Insight: += [childCon] adds the whole child container as a single element in parentCon. Without square brackets ([]), it unpacks the child and appends individual elements. âš ï¸ ğŸ§ª Solution 2: Using conIns() (Insert at Specific Index) If you want more control â€” like inserting at the beginning or a specific position â€” conIns() is your friend.\nstatic void InsertUsingConIns(Args _args) { container parentCon; container childCon; int id; str name; for (int i = 1; i \u0026lt;= 5; i++) { id = i; name = strFmt(\u0026#34;Name_%1\u0026#34;, i); childCon = conNull(); childCon += id; childCon += name; // Insert at the end using length + 1 parentCon = conIns(parentCon, [childCon], conLen(parentCon) + 1); } // (Optional) we print to verify for (int j = 1; j \u0026lt;= conLen(parentCon); j++) { container row = conPeek(parentCon, j); info(strFmt(\u0026#34;Row %1 â¡ ID: %2, Name: %3\u0026#34;, j, conPeek(row, 1), conPeek(row, 2))); } } ğŸ§  Why Use conIns()? Great when order matters! Insert at start, middle, or end by changing the index: parentCon = conIns(parentCon, [childCon], 1); // Insert at beginning ğŸ› ï¸ Summary Feature += conIns() Append at end âœ… Simple and readable âœ… More verbose Insert at position âŒ Not possible âœ… Can insert anywhere Performance âš¡ Fast âš¡ Fast (but slightly more overhead) Readability âœ… Clean ğŸ› ï¸ Useful for ordered inserts ğŸ’¬ Final Thoughts This is a go-to technique in D365 FinOps or AX development when:\nCreating nested in-memory records Building payloads for AIF/JSON/XML Simulating rows like a mini temp table ğŸ§° Pro Tip: Wrap your logic in a helper method or class to reuse it across multiple jobs or classes!\nHappy coding, devs! ğŸš€ğŸ§‘â€ğŸ’»\nLet your containers contain with confidence!\nğŸ“š More Resources ğŸ”— Insert Containers into Container in X++ (Original Reference)\nA classic community blog post showing the basics of nesting containers in X++.\nğŸ“˜ Microsoft Learn â€“ Data Types: Container\nThe official documentation for understanding containers, conPeek(), conIns(), and more in X++.\n","permalink":"http://localhost:1313/blogs/1-xppcontainerception/","summary":"\u003cp\u003eğŸ§Š \u003cstrong\u003eEver wanted to insert one container inside another in X++?\u003c/strong\u003e\u003cbr\u003e\nWhether you\u0026rsquo;re working with temporary in-memory structures or building payloads for integrations, this trick can help you dynamically group rows into containers â€” just like a 2D array!\u003c/p\u003e\n\u003cp\u003eLetâ€™s dive in. ğŸ’»\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"-the-problem\"\u003eğŸš€ The Problem\u003c/h2\u003e\n\u003cp\u003eYou want to loop through a dataset (like IDs and names), create a container for each row, and \u003cstrong\u003enest those containers into one master container\u003c/strong\u003e.\u003c/p\u003e","title":"ğŸ¥¡ How to Pack a Container Like a Bengali Mom Packs a Lunchbox"},{"content":"ğŸ§  Passing Extra Data in X++ using Disposable Contexts Ever hit that wall in X++ where you want to pass some extra data downstream â€” maybe from a CoC extension or a wrapped method â€” but canâ€™t because the method signature is untouchable? ğŸ¤¯\nDon\u0026rsquo;t worry, youâ€™re not alone. In D365 F\u0026amp;O, it\u0026rsquo;s a common situation. Luckily, thereâ€™s a pattern that comes to the rescue like a hero on a white horse: the Disposable Context ğŸ´ğŸ’¾\nğŸ§ What Problem Are We Solving? Imagine youâ€™re extending a standard framework class and need to get a value (say, a journal ID) thatâ€™s created deep down in the call stack â€” without modifying any signatures or breaking extensibility rules.\nYou might think of using static variablesâ€¦ but wait â€” how do you clean them up reliably?\nEnter: System.IDisposable + using + Singleton Context = âœ… Clean, type-safe, and scoped data transfer across classes.\nğŸ§© How the Pattern Works Hereâ€™s the big idea:\nYou create a singleton context class that holds your data. You wrap your call inside a using block. Downstream code can get the current context and write to it. When you\u0026rsquo;re done, the context is disposed automatically â€” cleaning up after itself! ğŸ§¼ Letâ€™s see a simplified version ğŸ‘‡\nğŸ§± The Disposable Context Class public final class ProdUpdReportFinishedRouteCardJournalContext implements System.IDisposable { private static ProdUpdReportFinishedRouteCardJournalContext instance; private ProdJournalId routeCardJournalId; private void new() { if (instance) throw error(Error::wrongUseOfFunction(funcName())); instance = this; } public static ProdUpdReportFinishedRouteCardJournalContext construct() { return new ProdUpdReportFinishedRouteCardJournalContext(); } public static ProdUpdReportFinishedRouteCardJournalContext current() { return instance; } public void dispose() { instance = null; } public ProdJournalId parmRouteCardJournalId(ProdJournalId _id = routeCardJournalId) { routeCardJournalId = _id; return routeCardJournalId; } } ğŸ—ï¸ Using the Context in a CoC Suppose, we want to retrieve ProdJournalTable.JournalId from the usedProdJournalTable() method and use it in the updateRouteConsumption() method to set parmRouteCardJournalId().\nHowever, since usedProdJournalTable() is being called inside (or after) updateRouteConsumption(), the ProdJournalTable buffer returned from it isnâ€™t maintained as a state and therefore isnâ€™t directly usable.\nSo, in this case, we can use the Disposable context.\nprotected void updateRouteConsumption() { using (ProdUpdReportFinishedRouteCardJournalContext context = ProdUpdReportFinishedRouteCardJournalContext::construct()) { next updateRouteConsumption(); ProdJournalId routeJournal = context.parmRouteCardJournalId(); this.parmRouteCardJournalId(routeJournal); } } ğŸ›°ï¸ Downstream Code Sets the Value public ProdJournalTable usedProdJournalTable() { ProdJournalTable tableRec = next usedProdJournalTable(); ProdUpdReportFinishedRouteCardJournalContext ctx = ProdUpdReportFinishedRouteCardJournalContext::current(); if (tableRec.JournalId \u0026amp;\u0026amp; ctx) { ctx.parmRouteCardJournalId(tableRec.JournalId); } return tableRec; } âš™ï¸ Why Not Use Overloading or Parameters? Because:\nX++ does not support method overloading. We canâ€™t change signatures of standard methods in extensions. Extensible parameters would be intrusive But with:\nA private new() constructor ğŸ§± Public construct() and current() ğŸšª Scoped dispose() in using ğŸ§¹ Youâ€™ve got a fully controlled, extensible, and clean pattern!\nâš ï¸ Caution:\nMoving state between arbitrary locations using a global variable â€” which is essentially what the context class is â€” can introduce subtle logical errors that may be extremely difficult to trace and resolve later. I recommend restricting its use to cases where the scope and potential side effects are clearly understood and controlled. That\u0026rsquo;s why some consider it as an anti-pattern also. ğŸ§¼ Cleanup is Key: Why IDisposable Matters Quoting .NET best practices (docs):\nThe purpose of IDisposable.Dispose() is to release unmanaged resources and clean up.\nIn our case:\nThe resource is the singleton static instance. Calling dispose() resets it, preventing data leaks or ghost values. ğŸ‘» ğŸ” Thread Safety and X++ Specifics X++ is:\nSingle-threaded per session Static variables are session-scoped, not global across users So if User A and User B both hit the same logic:\nThey get different static instances of the context ğŸ” Safe from cross-user interference But still:\nDonâ€™t use this as a global state store! Keep it scoped to one logical operation.\nğŸ¯ When to Use Disposable Contexts âœ… When:\nYou need to transfer additional data downstream in a CoC chain You canâ€™t modify method signatures You want type safety and automatic cleanup ğŸš« Avoid:\nNesting contexts too deep Holding context open across unrelated logic Using as a long-lived cache ğŸ’¬ Final Thoughts Disposable Contexts are like invisible backpacks ğŸ’ you carry into a function call â€” drop things into them downstream, and unpack them when you return!\nTheyâ€™re powerful, clean, and surprisingly elegant for tricky X++ problems involving CoCs, journal creation, or layered customization.\nNext time youâ€™re stuck thinking â€œHow do I pass this value without breaking everything?â€, remember: Context is King ğŸ‘‘\nğŸ“š More Resources ğŸ”— Implementing IDisposable â€“ Microsoft Learn (.NET)\nCovers the purpose and best practices around System.IDisposable, which inspired the safe cleanup pattern in X++.\nğŸ”— Disposable Context for X++ â€“ Dynamics Community Blog\nThe original guide demonstrating 3 approaches to pass data in X++, where Option 3 (Disposable Context) shines as a flexible and extensible solution.\nğŸ”— Disposable context and concurrency\nClarifies how static variables behave in AX/D365, supporting the safety of singleton patterns like the Disposable Context.\nğŸ”— Garbage Collection and Memory Management in .NET\nExplains how cleanup and memory management work under the hood when using IDisposable in managed code â€” relevant since D365 F\u0026amp;O runs on .NET.\n","permalink":"http://localhost:1313/blogs/2-disposablecontext/","summary":"\u003ch1 id=\"-passing-extra-data-in-x-using-disposable-contexts\"\u003eğŸ§  Passing Extra Data in X++ using Disposable Contexts\u003c/h1\u003e\n\u003cp\u003eEver hit that wall in X++ where you want to pass some extra data downstream â€” maybe from a CoC extension or a wrapped method â€” but canâ€™t because the method signature is untouchable? ğŸ¤¯\u003c/p\u003e\n\u003cp\u003eDon\u0026rsquo;t worry, youâ€™re not alone. In D365 F\u0026amp;O, it\u0026rsquo;s a common situation. Luckily, thereâ€™s a pattern that comes to the rescue like a hero on a white horse: the \u003cstrong\u003eDisposable Context\u003c/strong\u003e ğŸ´ğŸ’¾\u003c/p\u003e","title":"Hold My Context While I CoC This ğŸºğŸª„"}]