[{"content":"🧊 Ever wanted to insert one container inside another in X++?\nWhether you\u0026rsquo;re working with temporary in-memory structures or building payloads for integrations, this trick can help you dynamically group rows into containers — just like a 2D array!\nLet’s dive in. 💻\n🚀 The Problem You want to loop through a dataset (like IDs and names), create a container for each row, and nest those containers into one master container.\nSounds simple — but you need to do it the right way to avoid mistakes like flattening your data.\n🧪 Solution 1: Using += (Append Operator) This is the cleanest and most common way to insert a container into another container.\nstatic void InsertUsingPlusEquals(Args _args) { container parentCon; container childCon; int id; str name; for (int i = 1; i \u0026lt;= 5; i++) { id = i; name = strFmt(\u0026#34;Name_%1\u0026#34;, i); childCon = conNull(); // Clear before reuse! childCon += id; childCon += name; parentCon += [childCon]; // Correct: Wrap in [] to insert as 1 item } // (Optional) we print to verify for (int j = 1; j \u0026lt;= conLen(parentCon); j++) { container row = conPeek(parentCon, j); info(strFmt(\u0026#34;Row %1 - ID: %2, Name: %3\u0026#34;, j, conPeek(row, 1), conPeek(row, 2))); } } 🔥 Key Insight: += [childCon] adds the whole child container as a single element in parentCon. Without square brackets ([]), it unpacks the child and appends individual elements. ⚠️ 🧪 Solution 2: Using conIns() (Insert at Specific Index) If you want more control — like inserting at the beginning or a specific position — conIns() is your friend.\nstatic void InsertUsingConIns(Args _args) { container parentCon; container childCon; int id; str name; for (int i = 1; i \u0026lt;= 5; i++) { id = i; name = strFmt(\u0026#34;Name_%1\u0026#34;, i); childCon = conNull(); childCon += id; childCon += name; // Insert at the end using length + 1 parentCon = conIns(parentCon, [childCon], conLen(parentCon) + 1); } // (Optional) we print to verify for (int j = 1; j \u0026lt;= conLen(parentCon); j++) { container row = conPeek(parentCon, j); info(strFmt(\u0026#34;Row %1 ➡ ID: %2, Name: %3\u0026#34;, j, conPeek(row, 1), conPeek(row, 2))); } } 🧠 Why Use conIns()? Great when order matters! Insert at start, middle, or end by changing the index: parentCon = conIns(parentCon, [childCon], 1); // Insert at beginning 🛠️ Summary Feature += conIns() Append at end ✅ Simple and readable ✅ More verbose Insert at position ❌ Not possible ✅ Can insert anywhere Performance ⚡ Fast ⚡ Fast (but slightly more overhead) Readability ✅ Clean 🛠️ Useful for ordered inserts 💬 Final Thoughts This is a go-to technique in D365 FinOps or AX development when:\nCreating nested in-memory records Building payloads for AIF/JSON/XML Simulating rows like a mini temp table 🧰 Pro Tip: Wrap your logic in a helper method or class to reuse it across multiple jobs or classes!\nHappy coding, devs! 🚀🧑‍💻\nLet your containers contain with confidence!\n📚 More Resources 🔗 Insert Containers into Container in X++ (Original Reference)\nA classic community blog post showing the basics of nesting containers in X++.\n📘 Microsoft Learn – Data Types: Container\nThe official documentation for understanding containers, conPeek(), conIns(), and more in X++.\n","permalink":"http://localhost:1313/blogs/1-xppcontainerception/","summary":"\u003cp\u003e🧊 \u003cstrong\u003eEver wanted to insert one container inside another in X++?\u003c/strong\u003e\u003cbr\u003e\nWhether you\u0026rsquo;re working with temporary in-memory structures or building payloads for integrations, this trick can help you dynamically group rows into containers — just like a 2D array!\u003c/p\u003e\n\u003cp\u003eLet’s dive in. 💻\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"-the-problem\"\u003e🚀 The Problem\u003c/h2\u003e\n\u003cp\u003eYou want to loop through a dataset (like IDs and names), create a container for each row, and \u003cstrong\u003enest those containers into one master container\u003c/strong\u003e.\u003c/p\u003e","title":"🥡 How to Pack a Container Like a Bengali Mom Packs a Lunchbox"},{"content":"🧠 Passing Extra Data in X++ using Disposable Contexts Ever hit that wall in X++ where you want to pass some extra data downstream — maybe from a CoC extension or a wrapped method — but can’t because the method signature is untouchable? 🤯\nDon\u0026rsquo;t worry, you’re not alone. In D365 F\u0026amp;O, it\u0026rsquo;s a common situation. Luckily, there’s a pattern that comes to the rescue like a hero on a white horse: the Disposable Context 🐴💾\n🧐 What Problem Are We Solving? Imagine you’re extending a standard framework class and need to get a value (say, a journal ID) that’s created deep down in the call stack — without modifying any signatures or breaking extensibility rules.\nYou might think of using static variables… but wait — how do you clean them up reliably?\nEnter: System.IDisposable + using + Singleton Context = ✅ Clean, type-safe, and scoped data transfer across classes.\n🧩 How the Pattern Works Here’s the big idea:\nYou create a singleton context class that holds your data. You wrap your call inside a using block. Downstream code can get the current context and write to it. When you\u0026rsquo;re done, the context is disposed automatically — cleaning up after itself! 🧼 Let’s see a simplified version 👇\n🧱 The Disposable Context Class public final class ProdUpdReportFinishedRouteCardJournalContext implements System.IDisposable { private static ProdUpdReportFinishedRouteCardJournalContext instance; private ProdJournalId routeCardJournalId; private void new() { if (instance) throw error(Error::wrongUseOfFunction(funcName())); instance = this; } public static ProdUpdReportFinishedRouteCardJournalContext construct() { return new ProdUpdReportFinishedRouteCardJournalContext(); } public static ProdUpdReportFinishedRouteCardJournalContext current() { return instance; } public void dispose() { instance = null; } public ProdJournalId parmRouteCardJournalId(ProdJournalId _id = routeCardJournalId) { routeCardJournalId = _id; return routeCardJournalId; } } 🏗️ Using the Context in a CoC protected void updateRouteConsumption() { using (ProdUpdReportFinishedRouteCardJournalContext context = ProdUpdReportFinishedRouteCardJournalContext::construct()) { next updateRouteConsumption(); ProdJournalId routeJournal = context.parmRouteCardJournalId(); this.parmRouteCardJournalId(routeJournal); } } 🛰️ Downstream Code Sets the Value public ProdJournalTable usedProdJournalTable() { ProdJournalTable tableRec = next usedProdJournalTable(); ProdUpdReportFinishedRouteCardJournalContext ctx = ProdUpdReportFinishedRouteCardJournalContext::current(); if (tableRec.JournalId \u0026amp;\u0026amp; ctx) { ctx.parmRouteCardJournalId(tableRec.JournalId); } return tableRec; } ⚙️ Why Not Use Overloading or Parameters? Because:\nX++ does not support method overloading. We can’t change signatures of standard methods in extensions. Extensible parameters would be intrusive But with:\nA private new() constructor 🧱 Public construct() and current() 🚪 Scoped dispose() in using 🧹 You’ve got a fully controlled, extensible, and clean pattern!\n⚠️ Caution:\nMoving state between arbitrary locations using a global variable — which is essentially what the context class is — can introduce subtle logical errors that may be extremely difficult to trace and resolve later. I recommend restricting its use to cases where the scope and potential side effects are clearly understood and controlled. That\u0026rsquo;s why some consider it as an anti-pattern also. 🧼 Cleanup is Key: Why IDisposable Matters Quoting .NET best practices (docs):\nThe purpose of IDisposable.Dispose() is to release unmanaged resources and clean up.\nIn our case:\nThe resource is the singleton static instance. Calling dispose() resets it, preventing data leaks or ghost values. 👻 🔐 Thread Safety and X++ Specifics X++ is:\nSingle-threaded per session Static variables are session-scoped, not global across users So if User A and User B both hit the same logic:\nThey get different static instances of the context 🔐 Safe from cross-user interference But still:\nDon’t use this as a global state store! Keep it scoped to one logical operation.\n🎯 When to Use Disposable Contexts ✅ When:\nYou need to transfer additional data downstream in a CoC chain You can’t modify method signatures You want type safety and automatic cleanup 🚫 Avoid:\nNesting contexts too deep Holding context open across unrelated logic Using as a long-lived cache 💬 Final Thoughts Disposable Contexts are like invisible backpacks 🎒 you carry into a function call — drop things into them downstream, and unpack them when you return!\nThey’re powerful, clean, and surprisingly elegant for tricky X++ problems involving CoCs, journal creation, or layered customization.\nNext time you’re stuck thinking “How do I pass this value without breaking everything?”, remember: Context is King 👑\n📚 More Resources 🔗 Implementing IDisposable – Microsoft Learn (.NET)\nCovers the purpose and best practices around System.IDisposable, which inspired the safe cleanup pattern in X++.\n🔗 Disposable Context for X++ – Dynamics Community Blog\nThe original guide demonstrating 3 approaches to pass data in X++, where Option 3 (Disposable Context) shines as a flexible and extensible solution.\n🔗 Disposable context and concurrency\nClarifies how static variables behave in AX/D365, supporting the safety of singleton patterns like the Disposable Context.\n🔗 Garbage Collection and Memory Management in .NET\nExplains how cleanup and memory management work under the hood when using IDisposable in managed code — relevant since D365 F\u0026amp;O runs on .NET.\n","permalink":"http://localhost:1313/blogs/2-disposablecontext/","summary":"\u003ch1 id=\"-passing-extra-data-in-x-using-disposable-contexts\"\u003e🧠 Passing Extra Data in X++ using Disposable Contexts\u003c/h1\u003e\n\u003cp\u003eEver hit that wall in X++ where you want to pass some extra data downstream — maybe from a CoC extension or a wrapped method — but can’t because the method signature is untouchable? 🤯\u003c/p\u003e\n\u003cp\u003eDon\u0026rsquo;t worry, you’re not alone. In D365 F\u0026amp;O, it\u0026rsquo;s a common situation. Luckily, there’s a pattern that comes to the rescue like a hero on a white horse: the \u003cstrong\u003eDisposable Context\u003c/strong\u003e 🐴💾\u003c/p\u003e","title":"Hold My Context While I CoC This 🍺🪄"},{"content":" “The best code is the one that doesn’t know too much.” — A wise developer (probably debugging a massive switch-case block)\n🐱‍🏍 Intro: The Anti-Switch Revolution Begins Do you wake up in cold sweat remembering a 100-line switch statement in your factory method?\nDoes adding a new subclass feel like open-heart surgery on a base class you don’t even own?\nWelcome to the land of SysExtension — where your factories are clean, your base classes are blissfully ignorant, and your subclasses just… show up when needed. 🪄\nLet’s dive into the SysExtension Framework in Dynamics 365 Finance \u0026amp; Operations — a magical potion brewed to slay switch-case monsters, decouple code, and help you sleep better at night. 🧘‍♂️\n🤖 What is SysExtension? Think of SysExtension as a matchmaking service between your base class and the perfect subclass — all powered by attributes and runtime magic. ✨\nIt works like this:\nYou tag your subclasses with an attribute. You call the SysExtension factory with the value you want. It finds the class that matches and poof — returns an instance. No if, no switch, no drama. 🧩 Why You Should Care ✅ No compile-time references to subclasses ✅ No messy switch-cases ✅ Add new classes without touching existing ones ✅ Works beautifully with extensible enums 🧠 The Theory (a.k.a What’s Actually Happening) Here’s how it all comes together behind the scenes:\nDefine a custom attribute to represent the key (enum, string, id, whatever). Decorate each subclass with that attribute. At runtime, create an instance of the attribute with the value you want. Call SysExtensionAppClassFactory::getClassFromSysAttribute() with: The base class name The attribute instance The framework uses reflection magic 🪄 to find the subclass with a matching attribute and returns an instance. You can even customize how instances are created (e.g., pass args to constructors), cache them, or replace the entire instantiation logic.\nLearn the internals here:\n🔗 Register subclass factory methods - Microsoft Learn\n🔗 SysExtension Framework to the rescue - Michael Fruergaard\n🔗 Development tutorial - Ivan Kashperuk\n🧪 Example: Barcodes Without the Switch-Case Headache 📦📏 Let’s say you need to create different barcode types dynamically — but you don’t want a massive switch block for each type.\nHere’s how SysExtension makes it clean, future-proof, and ready for new barcode types without touching your factory code.\n1. Define Attribute /// \u0026lt;summary\u0026gt; /// The \u0026lt;c\u0026gt;BarcodeTypeFactoryAttribute\u0026lt;/c\u0026gt; is an attribute used for instantiating classes. /// \u0026lt;/summary\u0026gt; class BarcodeTypeFactoryAttribute extends SysAttribute implements SysExtensionIAttribute { BarcodeType barcodeType; public void new(BarcodeType _barcodeType) { barcodeType = _barcodeType; } /// \u0026lt;summary\u0026gt; /// Returns the key used for storing cached data for this attribute. /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt; /// A string representing the cache key. /// \u0026lt;/returns\u0026gt; /// \u0026lt;remarks\u0026gt; /// The key typically includes the class name and relevant members. /// The key must be invariant across different languages, e.g. use int2str() instead of enum2str() when including enum members. /// \u0026lt;/remarks\u0026gt; public str parmCacheKey() { return classStr(BarcodeTypeFactoryAttribute)+\u0026#39;;\u0026#39;+int2str(enum2int(barcodeType)); } /// \u0026lt;summary\u0026gt; /// Determines if the same instance should be returned by the extension framework for a given extension. /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt; /// true, if the same instance should be used; otherwise, false. /// \u0026lt;/returns\u0026gt; /// \u0026lt;remarks\u0026gt; /// When returning false, the SysExtension framework will create a new class instance for every invocation. /// If the class is immutable, consider returning true to save memory and gain performance. /// \u0026lt;/remarks\u0026gt; public boolean useSingleton() { return false; } } 2. Base class/ The factory code public static Barcode construct(BarcodeType _barcodeType) { Barcode barcode = Barcode::constructNoThrow(_barcodeType); if (!barcode) { throw error(Error::wrongUseOfFunction(funcName())); } return barcode; } /// \u0026lt;summary\u0026gt; /// Instantiates a \u0026lt;c\u0026gt;Barcode\u0026lt;/c\u0026gt; object from a bar code type. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name = \u0026#34;_barcodeType\u0026#34;\u0026gt;The bar code type.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;The instantiated object; otherwise, null.\u0026lt;/returns\u0026gt; public static Barcode constructNoThrow(BarcodeType _barcodeType) { BarcodeTypeFactoryAttribute attr = new BarcodeTypeFactoryAttribute(_barcodeType); Barcode barcode = SysExtensionAppClassFactory::getClassFromSysAttribute(classStr(Barcode), attr) as Barcode; return barcode; } 3. Registering the sub classes is so easy now! [BarcodeTypeFactory(BarcodeType::Code39)] public class BarcodeCode39 extends Barcode { } [BarcodeTypeFactory(BarcodeType::Code128)] public class BarcodeCode128 extends Barcode { } 4. Use It! public static str generateBarCode(str _barCodeString) { Barcode barcode; barcode = Barcode::construct(BarcodeType::Code128); barcode.string(true, _barCodeString); barcode.encode(); return barcode.barcodeStr(); } 🧼 Cleaning Up: Cache Matters ⚠️ When adding new classes to a SysExtension framework, you might notice they don’t get picked up immediately. This happens because the SysExtension factory aggressively caches class IDs and attributes.\nEven after a full build, sync, and IISRESET, the cache can survive — meaning your new subclass won’t be instantiated.\nSolution: Run the following SysClassRunnerin your browser (replace with your environment base URL):\nClear it with:\n\u0026lt;EnvironmentBaseURL\u0026gt;/?mi=SysClassRunner\u0026amp;cls=SysFlushAOD This executes SysFlushAOD, which flushes the SysExtension cache and forces a re-scan of inherited classes. After that, reload your session — your new class should now be recognized.\n🤹‍♀️ Advanced: Pass Arguments Like a Pro (Journal Table Example) Sometimes you need to pass arguments into your extensions, especially when your subclasses don’t have parameterless constructors.\nThat’s where SysExtensionIInstantiationStrategy comes in. Think of it as a fancy butler that delivers your constructor arguments exactly where they need to go. 🛎\nLet\u0026rsquo;s see an classic example of JournalTableData that uses SysExtensionGenericInstantiation\n/// \u0026lt;summary\u0026gt; /// The \u0026lt;c\u0026gt;SysExtensionGenericInstantiation\u0026lt;/c\u0026gt; class is a generic initialization class for subclasses without parameterless constructors. /// \u0026lt;/summary\u0026gt; public class SysExtensionGenericInstantiation implements SysExtensionIInstantiationStrategy { anytype arg1; anytype arg2; anytype arg3; anytype arg4; anytype arg5; int numOfArguments; /// \u0026lt;summary\u0026gt; /// Creates an instance of the subclass. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;_element\u0026#34;\u0026gt; /// The element that represents the subclass to create. /// \u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt; /// An instance of the subclass. /// \u0026lt;/returns\u0026gt; public anytype instantiate(SysExtModelElement _element) { SysExtModelElementApp appElement = _element as SysExtModelElementApp; if (appElement) { SysDictClass dictClass = SysDictClass::newName(appElement.parmAppName()); if (dictClass) { switch (numOfArguments) { case 0: return dictClass.makeObject(); case 1: return dictClass.makeObject(arg1); case 2: return dictClass.makeObject(arg1, arg2); case 3: return dictClass.makeObject(arg1, arg2, arg3); case 4: return dictClass.makeObject(arg1, arg2, arg3, arg4); case 5: return dictClass.makeObject(arg1, arg2, arg3, arg4, arg5); } } } return null; } public void new( anytype _arg1 = 0, anytype _arg2 = 0, anytype _arg3 = 0, anytype _arg4 = 0, anytype _arg5 = 0 ) { if (!prmIsDefault(_arg1)) { this.arg1 = _arg1; this.numOfArguments++; } if (!prmIsDefault(_arg2)) { this.arg2 = _arg2; this.numOfArguments++; } if (!prmIsDefault(_arg3)) { this.arg3 = _arg3; this.numOfArguments++; } if (!prmIsDefault(_arg4)) { this.arg4 = _arg4; this.numOfArguments++; } if (!prmIsDefault(_arg5)) { this.arg5 = _arg5; this.numOfArguments++; } super(); } } Putting It to Work: JournalTableData Now let’s use it to construct JournalTableData with a JournalTableMap argument:\npublic static JournalTableData newTable(JournalTableMap _journalTable) { return JournalTableData::construct(_journalTable); } private static JournalTableData construct(JournalTableMap _journalTable) { SysTableNameFactoryAttribute attribute = new SysTableNameFactoryAttribute(tableId2Name(_journalTable.TableId)); SysExtensionGenericInstantiation instantiation = new SysExtensionGenericInstantiation(_journalTable); JournalTableData instance = SysExtensionAppClassFactory::getClassFromSysAttributeWithInstantiationStrategy(classStr(JournalTableData), attribute, instantiation); if (!instance) { instance = new JournalTableData(_journalTable); } return instance; } 💡 Why this is awesome:\nYou can keep your subclasses clean and argument-friendly without forcing them to have a sad, empty default constructor.\nYou gain flexibility — pass different arguments based on runtime conditions.\nIt makes your factory methods powerful without bloating them with switch-case type logic.\nBoom. Constructor params like a boss. 💥\n🎯 Final Thoughts: Why SysExtension is Your New Best Friend You write less. You extend more. You switch never. 😎 If your architecture needs flexibility, decoupling, and clean extensibility — this is the D365FO design pattern to embrace. 💡\n📚 More Resources 🔗 Microsoft Learn: Register subclass factory methods 🔗 Michael Fruergaard Pontoppidan’s Blog 🔗 Ivan Kashperuk’s Walkthrough Happy coding, factory workers warriors! 🧙‍♂️🐈\n","permalink":"http://localhost:1313/blogs/3-sysextensionfactoryfun/","summary":"\u003cblockquote\u003e\n\u003cp\u003e“The best code is the one that doesn’t know too much.” — A wise developer (probably debugging a massive \u003ccode\u003eswitch-case\u003c/code\u003e block)\u003c/p\u003e\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2 id=\"-intro-the-anti-switch-revolution-begins\"\u003e🐱‍🏍 Intro: The Anti-Switch Revolution Begins\u003c/h2\u003e\n\u003cp\u003eDo you wake up in cold sweat remembering a 100-line \u003ccode\u003eswitch\u003c/code\u003e statement in your factory method?\u003cbr\u003e\nDoes adding a new subclass feel like open-heart surgery on a base class you don’t even own?\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWelcome to the land of \u003ccode\u003eSysExtension\u003c/code\u003e\u003c/strong\u003e — where your factories are clean, your base classes are blissfully ignorant, and your subclasses just… show up when needed. 🪄\u003c/p\u003e","title":"🔌 SysExtension Framework in D365FO: How I Learned to Stop Worrying and Love the Factory"}]