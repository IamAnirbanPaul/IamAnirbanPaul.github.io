[{"content":"🧊 Ever wanted to insert one container inside another in X++?\nWhether you\u0026rsquo;re working with temporary in-memory structures or building payloads for integrations, this trick can help you dynamically group rows into containers — just like a 2D array!\nLet’s dive in. 💻\n🚀 The Problem You want to loop through a dataset (like IDs and names), create a container for each row, and nest those containers into one master container.\nSounds simple — but you need to do it the right way to avoid mistakes like flattening your data.\n🧪 Solution 1: Using += (Append Operator) This is the cleanest and most common way to insert a container into another container.\nstatic void InsertUsingPlusEquals(Args _args) { container parentCon; container childCon; int id; str name; for (int i = 1; i \u0026lt;= 5; i++) { id = i; name = strFmt(\u0026#34;Name_%1\u0026#34;, i); childCon = conNull(); // Clear before reuse! childCon += id; childCon += name; parentCon += [childCon]; // Correct: Wrap in [] to insert as 1 item } // (Optional) we print to verify for (int j = 1; j \u0026lt;= conLen(parentCon); j++) { container row = conPeek(parentCon, j); info(strFmt(\u0026#34;Row %1 - ID: %2, Name: %3\u0026#34;, j, conPeek(row, 1), conPeek(row, 2))); } } 🔥 Key Insight: += [childCon] adds the whole child container as a single element in parentCon. Without square brackets ([]), it unpacks the child and appends individual elements. ⚠️ 🧪 Solution 2: Using conIns() (Insert at Specific Index) If you want more control — like inserting at the beginning or a specific position — conIns() is your friend.\nstatic void InsertUsingConIns(Args _args) { container parentCon; container childCon; int id; str name; for (int i = 1; i \u0026lt;= 5; i++) { id = i; name = strFmt(\u0026#34;Name_%1\u0026#34;, i); childCon = conNull(); childCon += id; childCon += name; // Insert at the end using length + 1 parentCon = conIns(parentCon, [childCon], conLen(parentCon) + 1); } // (Optional) we print to verify for (int j = 1; j \u0026lt;= conLen(parentCon); j++) { container row = conPeek(parentCon, j); info(strFmt(\u0026#34;Row %1 ➡ ID: %2, Name: %3\u0026#34;, j, conPeek(row, 1), conPeek(row, 2))); } } 🧠 Why Use conIns()? Great when order matters! Insert at start, middle, or end by changing the index: parentCon = conIns(parentCon, [childCon], 1); // Insert at beginning 🛠️ Summary Feature += conIns() Append at end ✅ Simple and readable ✅ More verbose Insert at position ❌ Not possible ✅ Can insert anywhere Performance ⚡ Fast ⚡ Fast (but slightly more overhead) Readability ✅ Clean 🛠️ Useful for ordered inserts 💬 Final Thoughts This is a go-to technique in D365 FinOps or AX development when:\nCreating nested in-memory records Building payloads for AIF/JSON/XML Simulating rows like a mini temp table 🧰 Pro Tip: Wrap your logic in a helper method or class to reuse it across multiple jobs or classes!\nHappy coding, devs! 🚀🧑‍💻\nLet your containers contain with confidence!\n📚 More Resources 🔗 Insert Containers into Container in X++ (Original Reference)\nA classic community blog post showing the basics of nesting containers in X++.\n📘 Microsoft Learn – Data Types: Container\nThe official documentation for understanding containers, conPeek(), conIns(), and more in X++.\n","permalink":"http://localhost:1313/blogs/1-xppcontainerception/","summary":"\u003cp\u003e🧊 \u003cstrong\u003eEver wanted to insert one container inside another in X++?\u003c/strong\u003e\u003cbr\u003e\nWhether you\u0026rsquo;re working with temporary in-memory structures or building payloads for integrations, this trick can help you dynamically group rows into containers — just like a 2D array!\u003c/p\u003e\n\u003cp\u003eLet’s dive in. 💻\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"-the-problem\"\u003e🚀 The Problem\u003c/h2\u003e\n\u003cp\u003eYou want to loop through a dataset (like IDs and names), create a container for each row, and \u003cstrong\u003enest those containers into one master container\u003c/strong\u003e.\u003c/p\u003e","title":"🥡 How to Pack a Container Like a Bengali Mom Packs a Lunchbox"},{"content":"🧠 Passing Extra Data in X++ using Disposable Contexts Ever hit that wall in X++ where you want to pass some extra data downstream — maybe from a CoC extension or a wrapped method — but can’t because the method signature is untouchable? 🤯\nDon\u0026rsquo;t worry, you’re not alone. In D365 F\u0026amp;O, it\u0026rsquo;s a common situation. Luckily, there’s a pattern that comes to the rescue like a hero on a white horse: the Disposable Context 🐴💾\n🧐 What Problem Are We Solving? Imagine you’re extending a standard framework class and need to get a value (say, a journal ID) that’s created deep down in the call stack — without modifying any signatures or breaking extensibility rules.\nYou might think of using static variables… but wait — how do you clean them up reliably?\nEnter: System.IDisposable + using + Singleton Context = ✅ Clean, type-safe, and scoped data transfer across classes.\n🧩 How the Pattern Works Here’s the big idea:\nYou create a singleton context class that holds your data. You wrap your call inside a using block. Downstream code can get the current context and write to it. When you\u0026rsquo;re done, the context is disposed automatically — cleaning up after itself! 🧼 Let’s see a simplified version 👇\n🧱 The Disposable Context Class public final class ProdUpdReportFinishedRouteCardJournalContext implements System.IDisposable { private static ProdUpdReportFinishedRouteCardJournalContext instance; private ProdJournalId routeCardJournalId; private void new() { if (instance) throw error(Error::wrongUseOfFunction(funcName())); instance = this; } public static ProdUpdReportFinishedRouteCardJournalContext construct() { return new ProdUpdReportFinishedRouteCardJournalContext(); } public static ProdUpdReportFinishedRouteCardJournalContext current() { return instance; } public void dispose() { instance = null; } public ProdJournalId parmRouteCardJournalId(ProdJournalId _id = routeCardJournalId) { routeCardJournalId = _id; return routeCardJournalId; } } 🏗️ Using the Context in a CoC Suppose, we want to retrieve ProdJournalTable.JournalId from the usedProdJournalTable() method and use it in the updateRouteConsumption() method to set parmRouteCardJournalId().\nHowever, since usedProdJournalTable() is being called inside (or after) updateRouteConsumption(), the ProdJournalTable buffer returned from it isn’t maintained as a state and therefore isn’t directly usable.\nSo, in this case, we can use the Disposable context.\nprotected void updateRouteConsumption() { using (ProdUpdReportFinishedRouteCardJournalContext context = ProdUpdReportFinishedRouteCardJournalContext::construct()) { next updateRouteConsumption(); ProdJournalId routeJournal = context.parmRouteCardJournalId(); this.parmRouteCardJournalId(routeJournal); } } 🛰️ Downstream Code Sets the Value public ProdJournalTable usedProdJournalTable() { ProdJournalTable tableRec = next usedProdJournalTable(); ProdUpdReportFinishedRouteCardJournalContext ctx = ProdUpdReportFinishedRouteCardJournalContext::current(); if (tableRec.JournalId \u0026amp;\u0026amp; ctx) { ctx.parmRouteCardJournalId(tableRec.JournalId); } return tableRec; } ⚙️ Why Not Use Overloading or Parameters? Because:\nX++ does not support method overloading. We can’t change signatures of standard methods in extensions. Extensible parameters would be intrusive But with:\nA private new() constructor 🧱 Public construct() and current() 🚪 Scoped dispose() in using 🧹 You’ve got a fully controlled, extensible, and clean pattern!\n⚠️ Caution:\nMoving state between arbitrary locations using a global variable — which is essentially what the context class is — can introduce subtle logical errors that may be extremely difficult to trace and resolve later. I recommend restricting its use to cases where the scope and potential side effects are clearly understood and controlled. That\u0026rsquo;s why some consider it as an anti-pattern also. 🧼 Cleanup is Key: Why IDisposable Matters Quoting .NET best practices (docs):\nThe purpose of IDisposable.Dispose() is to release unmanaged resources and clean up.\nIn our case:\nThe resource is the singleton static instance. Calling dispose() resets it, preventing data leaks or ghost values. 👻 🔐 Thread Safety and X++ Specifics X++ is:\nSingle-threaded per session Static variables are session-scoped, not global across users So if User A and User B both hit the same logic:\nThey get different static instances of the context 🔐 Safe from cross-user interference But still:\nDon’t use this as a global state store! Keep it scoped to one logical operation.\n🎯 When to Use Disposable Contexts ✅ When:\nYou need to transfer additional data downstream in a CoC chain You can’t modify method signatures You want type safety and automatic cleanup 🚫 Avoid:\nNesting contexts too deep Holding context open across unrelated logic Using as a long-lived cache 💬 Final Thoughts Disposable Contexts are like invisible backpacks 🎒 you carry into a function call — drop things into them downstream, and unpack them when you return!\nThey’re powerful, clean, and surprisingly elegant for tricky X++ problems involving CoCs, journal creation, or layered customization.\nNext time you’re stuck thinking “How do I pass this value without breaking everything?”, remember: Context is King 👑\n📚 More Resources 🔗 Implementing IDisposable – Microsoft Learn (.NET)\nCovers the purpose and best practices around System.IDisposable, which inspired the safe cleanup pattern in X++.\n🔗 Disposable Context for X++ – Dynamics Community Blog\nThe original guide demonstrating 3 approaches to pass data in X++, where Option 3 (Disposable Context) shines as a flexible and extensible solution.\n🔗 Disposable context and concurrency\nClarifies how static variables behave in AX/D365, supporting the safety of singleton patterns like the Disposable Context.\n🔗 Garbage Collection and Memory Management in .NET\nExplains how cleanup and memory management work under the hood when using IDisposable in managed code — relevant since D365 F\u0026amp;O runs on .NET.\n","permalink":"http://localhost:1313/blogs/2-disposablecontext/","summary":"\u003ch1 id=\"-passing-extra-data-in-x-using-disposable-contexts\"\u003e🧠 Passing Extra Data in X++ using Disposable Contexts\u003c/h1\u003e\n\u003cp\u003eEver hit that wall in X++ where you want to pass some extra data downstream — maybe from a CoC extension or a wrapped method — but can’t because the method signature is untouchable? 🤯\u003c/p\u003e\n\u003cp\u003eDon\u0026rsquo;t worry, you’re not alone. In D365 F\u0026amp;O, it\u0026rsquo;s a common situation. Luckily, there’s a pattern that comes to the rescue like a hero on a white horse: the \u003cstrong\u003eDisposable Context\u003c/strong\u003e 🐴💾\u003c/p\u003e","title":"Hold My Context While I CoC This 🍺🪄"}]